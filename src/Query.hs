module Query where

-- import Arg.Parser
-- import Control.Exception
-- import Data.Aeson hiding (Error)
-- import qualified Data.ByteString.Lazy.Char8 as BL
-- import Data.Fixed
-- import Data.List
-- import Data.Maybe
-- import Data.Time
-- import Event
-- import Response
-- import State
-- import Store
-- import System.Process (system)
-- import Task
-- import Text.Read

-- handleQueryArg :: QueryArg -> IO ()
-- handleQueryArg query = do
--   now <- getCurrentTime
--   evts <- readEvents
--   let state = buildStateFromEvents now evts
--   execute state query

-- execute :: State -> QueryArg -> IO ()
-- execute state (List opts) = putStrLn $ show opts

-- execute state query = do
--   let rtype = if Parsec._json (Parsec._opts args) then JSON else Text
--   let more = Parsec._more (Parsec._opts args)
--   case query of
--     List args -> listTasks args state query rtype
--     Info args -> do
--       now <- getCurrentTime
--       let ctx = _ctx state
--       let id = head $ Parsec._ids args
--       let fByTags = filterByTags $ _ctx state
--       let fByDone = filterByDone $ "done" `elem` ctx
--       let fByNumber = findById id
--       let maybeTask = fByNumber . fByTags . fByDone $ _tasks state
--       case maybeTask of
--         Nothing -> printErr rtype $ "show: task [" ++ show id ++ "] not found"
--         Just task -> printTask rtype task {_wtime = getTotalWtime now task}
--     Wtime args -> do
--       now <- getCurrentTime
--       let tags = Parsec._tags args `union` _ctx state
--       let min = Parsec.parseMinDate now args
--       let max = Parsec.parseMaxDate now args
--       let refs = map _ref $ filterByTags tags $ _tasks state
--       let tasks = filterByRefs refs $ _tasks state
--       let wtime = getWtimePerDay now min max tasks
--       let ctx = if null tags then "global" else "for [" ++ unwords tags ++ "]"
--       printWtime rtype more ("unfog: wtime " ++ ctx) wtime
--     Status -> do
--       now <- getCurrentTime
--       case filter ((> 0) . _active) $ _tasks state of
--         [] -> printEmptyStatus rtype
--         task : _ -> printStatus rtype task
--     Upgrade ->
--       system
--         "curl -sSL https://raw.githubusercontent.com/soywod/unfog.cli/master/bin/install.sh | sh"
--         >> return ()
--     Version -> printVersion rtype "0.4.5"

-- listTasks :: Parsec.Arg -> State -> Query -> ResponseType -> IO ()
-- listTasks args state query rtype
--   | Parsec._onlyIds (Parsec._opts args) =
--     printTasksId rtype . map Task._id . fByTags . fByDone $ allTasks
--   | Parsec._onlyTags (Parsec._opts args) =
--     printTasksTags rtype . nub . concatMap Task._tags $ allTasks
--   | otherwise =
--     do
--       now <- getCurrentTime
--       let ctx = _ctx state
--       let fByTags = filterByTags ctx
--       let fByDone = filterByDone $ "done" `elem` ctx
--       let tasks = mapWithWtime now . fByTags . fByDone $ _tasks state
--       let ctxStr = if null ctx then "" else " [" ++ unwords ctx ++ "]"
--       let onlyIds = Parsec._onlyIds (Parsec._opts args)
--       let onlyTags = Parsec._onlyTags (Parsec._opts args)
--       printTasks rtype ("unfog: list" ++ ctxStr) tasks
--   where
--     allTasks = _tasks state
--     fByTags = filterByTags . _ctx $ state
--     fByDone = filterByDone . elem "done" . _ctx $ state
